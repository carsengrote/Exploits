This vulnerability is more subtle. The length of buf is 200 bytes, but outl is 200 bytes and
the for loop is for i = 0 to i = 200 inclusive, thus we write 201 bytes to the buffer,
one byte past the end.  The one byte past the end of the buffer is the base pointer for foo,
used when bar returns to foo.  Thus we can overwrite the least significant byte of foo's saved
ebp.  Therefore we change it to point into the last few bytes of the buffer that we've written
into.  Therefore when foo's saved ebp is restored the resulting ebp will be within our buff.
In the end of our buffer, we copy (multiple times) an address that is towards the middle of
the buff, around 100 bytes in.  Therefore foo's ebp is near the end of our buffer where
all that is stored is the address of the middle of the buffer.  Once control returns to foo
it immediately returns to main, thus the value at the saved ebp is interpreted as main's saved
ebp.  More importantly the saved address 4 bytes above is interpreted as main's saved EIP,
which we have copied the address of the middle of the buff into.  Therefore when the EIP for main
is restored it really is the middle of the buff, where we have stored many NOPs, then our
shellcode.  Thus the EIP points to the many NOPs which are executed then our shellcode
is lastly executed.
