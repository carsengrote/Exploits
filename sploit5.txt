We ultimately were unsuccessful with this one, even after pouring a lot of time in it. We feel that we have a decent idea of how this sploit is done, but weren't quite able to make the program make use of the exploit.

We found the 3 resources helpful:
 -Exploit 101 - Format Strings - BreakInSecurity (axcheron.github.io) [https://axcheron.github.io/exploit-101-format-strings/]
 - Introduction to format string exploits (codearcana.com) [https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html]
  - Format String Exploit - Tutorial [https://www.exploit-db.com/docs/english/28476-linux-format-string-exploitation.pdf]

The general idea we attempted: format string exploits can write bytes to specific places in memory, so (as in the above resources), we attempted to write the target address (the location of the shellcode) to the main destructor (__DTOR_END__), located at 0x080495b4). 
 
Our proposed sploit input to the buffer was:
 (low memory)
 - chars   0:299: [format string exploit*] 
 - chars 300:399: [NOP sled]
 - chars 400:479: [shellcode, 45 characters] 
 (high memory)


We found that the input buffer was stored at 0xbffffc58, so ultimately we wanted to replace the pointer at __DTOR_END__ (0x080495b4) to contain buff+350 (putting us in the middle of the middle of the NOP sled, or 0xbffffdb6). 

For the format string exploit, we found that the input was the 10th item from the bottom of the stack, so our attempted format string exploit consisted of:
 (low memory)
   [__DTOR_END__ pointer, backwards]
   [4 characters]
   [__DTOR_END__ pointer + 2, backwards]
   [4 characters]
   [%x times 8]
   [%cx, where c sets __DTOR_END__ pointer + 2 to contain "fdb6" to int256]
   [%n]
   [%cx, where c sets __DTOR_END__ pointer + 0 to contain "bfff" to int256]
   [%n]
 (high memory)

Ultimately, we weren't able to get this exploit to work (we had trouble setting arbitrary values to __DTOR_END__ with %n), but we felt like we got pretty close. 