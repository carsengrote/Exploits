This is a double free vulnerability.  p and q are malloced with sizes 300 and 200, respectively
at the start.  Then both pointers are freed, p is then malloced for 2048, our given string is
copied into p.  Lastly q is freed again for the second time, which is the problem. Using gdb we find the memory
location that q points to when it is first malloced, which is constant.  Note that a memory pointer points to
the first byte of user data for that malloc, the 4 bytes before the pointer point to the next memory block,
8 bytes before the pointer points to the previous memory block.  The least significant bit of the pointer to the
next memory block is the free bit.  Memory blocks during malloc are 8-byte aligned.  When free is called on a
pointer, the memory block's previous and next blocks are checked.  If either are marked as free then the two
blocks are consolidated into one and pointers are updated, i.e. the left block's next pointer is set to the
next pointer of the right block, and vice versa for the last pointers.

Now, when free is called a second time on q, it's left and right pointers are checked for possible consolidation.
We input the program an arbitrary string that is written into p, and over the locaiton that was occupied by
q's data when it was first malloced, thus we can write arbitrary data over q's left and right pointers.
The idea of the exploit is to write in a fake memory block before q's and overwrite q's left pointer to point
to that memory block, and q's right pointer to point to the stack such that obsd_strlcpy's return address to main
is interpreted as the left pointer of q's next block.  Thus when q is freed, it's next pointer is checked and
is the location of obsd_strlcpy's return address.  q's left address is checked and is the fake block we put in
our input that is written to memory before q and is crafted such that it is marked as free.  Thus q and the
fake block to it's left are consolidated.  The fake blocks next pointer is updated to the stack address of
the location of obsd_strlcpy's return address.  Since the location of obsd_strlcpy's return address is written
as the next block of q, it is updated such that it's left pointer is now our fake block.  Thus the return
address of obsd_strlcpy is overwritten and is now the location of our fake block (really is the left pointer of
our fake block).  The fake block's left pointer, which is now the return address of obsd_strlcpy, is a jump
instruction to jump 32 bytes into the large memory space that lies inbetween our fake block and q.  In there
we copied many NOP instructions and the given shell code.  Thus when obsd_strlcpy returns, the location of the
left pointer of our fake block is the new return address.  The instruction lying at that address is the jump,
which makes the progam jump into NOPs and our shellcode.  Used gdb a lot to figure out these specific memory
locations for crafting the input string.