This is an integer overflow exploit.  The leading number in argv[1] is casted from an unsigned long
to an integer.  Thus if it is larger than 2147483647 (the max positive signed int) then it is taken
with a modulus and converted to an int, so 2147483648 becomes -2147483648 since 2147483648 is 32 bits
with the all zeros and a 1 in the most significant bit.  However, ints are signed thus with two's
compliment and reading this number as a signed int it is then interpreted as the largest negative
number. Therefore, after some binary math, we find that the number 2147483817, when converted to
binary and interpreted as a signed 32 bit integer is a very large, negative number since the 32nd
bit is set.  However, since sizeof returns an unsigned 32 bit int the count variable is upgraded
to be treated as a 32 bit unsigned int again, thus taking back the value 2147483817 and then is
multiplied by 16 (the size of widget_t) which is equivalent to bitshifting it to the left by
4 bits and back filling with zeros, which results in the positive number 2704 since the far left
zero is discarded.  Thus we get to write 2704 bytes to the buffer which is of size 2640.  Again
after checking the registers and assembly code of foo in gdb we find the correct address near the
start of the buffer when the input string is 2704 bytes.  We format the string to write to the buf
as follows: many NOPs, the shell code, then the address near the start of the buffer repeated a number
of times.  Since the written string is considerably longer than buf we end up overwriting the memory
at the ebp of foo, and the return address for main with our chosen address to return to.
Our CLA for the program is the number 2147483817 followed by a comma and followed by our
2704 byte long string with NOPs, shellcode, and the address.